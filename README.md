# CoSim: An Instruction-Level Simulator for Systolic Array-based Matrix Engine in a CPU Paradigm

# Requirements & Setup
- LLVM/Clang/MLIR-22
- YAML
- Python 3.11
- IREE 3.8.0
- ONNX 1.19.1

# Prepare
1. Please search the repository to replace `/staff/haoxiaoyu/mlir_project/llvm-project/build/externals/llvm-project/install/lib` to your own mlir lib path

2. Check hardware config file, e.g., `sim/boom_ws.yml`. If you want to use DRAMSim2, please change the DRAM config paths first. 
```
DRAM:
  simple: false
  ...
  system : "/path/to/cosim/sim/DDR3_micron_16M_8B_x8_sg3.txt"
  device : "/path/to/cosim/sim/DDRsys.txt"
```

```bash
git clone 
cd cosim
export BASE_PATH=/path/to/cosim/
export INST_LIB_PATH=/path/to/cosim/llvm
```
# Compile
## Compile LLVM Pass

```bash
cd llvm
mkdir build && cd build
cmake ..
make -j
```

## Compile MLIR Pass

```bash
cd mlir
mkdir build && cd build
cmake ..
make -j
```

## Compile Simulator

```bash
cd sim
mkdir build && cd build
cmake ..
make -j
```

## Compile Runtime Interface

```bash
cd gemmini_interface
./gen_ir.sh
```

## Compile Wrapper for DNNs

```bash
cd test_dnn
./gen_ir.sh
```

# Run
## gemmini-rocc-tests
Running Conv and Matmuls as an example.

```bash
cd gemmini-rocc-tests
cd convs_mms
make -j
./run_convmm_sims_ws_mm.h
```


## Run Pytorch DNN End-to-End

```bash
cd pytorch
python3 resnet.py
./convert.sh
./compile.sh
./run.sh
```

## Run Pytorch DNN with Simpoint

Note: please replace `-L/staff/haoxiaoyu/mlir_project/llvm-project/build/externals/llvm-project/install/lib` to your mlir path.

1. Run the command
```bash
cd pytorch
python3 resnet.py
./convert.sh
./compile_simpoint.sh
```

2. After running above commands, an executable named `resnet_profile` will be generated. Run it on a real machine:

```bash
./resnet_profile
```

Then you will see `example.txt`, a file of basic block vectors, is generated. This may take some time depending on your DNN.

Input this file to simpoint to determine which code chunk to run. Simpoint will output a line number, representing the code chunk id. 

`compile_simpoint.sh` is hard coded code with a chunk of 2000000 instructions, you can change it.

3. Compile the trace collection executable. `opt.bc` is generated by compile.sh

```bash
opt -load-pass-plugin $INST_LIB_PATH/build/libinstrument.so -passes=instrumentPass -threshold 2000000 -interval 9 -simpoint 1 < opt.bc > combine_inst.bc
clang++ combine_inst.bc -L/path/to/your/mlir/lib -lmlir_c_runner_utils -lm -L$BASE_PATH/manual/build -lmanual_interface  -L$INST_LIB_PATH/build -llog_helper -o resnet
```

4. Run the executable on a real machine:

```bash
./resnet
```

You will get three files: `funcname.txt`, `start_bb.txt`, and `example.txt`. `example.txt` is the trace file.

5. Get the start Basic block name:

```bash
cat start_bb.txt
```

6. Run the simulator:
```base
$BASE_PATH/sim/build/my_program opt.bc example.txt $BASE_PATH/sim/boom_ws.yml r1160 funcname.txt
```

`r1160` is combination of the character `r` and the number in `start_bb.txt`.

# Note
Indirect functions calls are only supported in running with simpoint.

You also need to add the `splibb` LLVM pass in `compile.sh`, like

```bash
opt -passes=lower-invoke,simplifycfg combine_rn.bc -o before_split.bc
opt -load-pass-plugin $INST_LIB_PATH/build/libsplit.so -passes=splitbb < before_split.bc > opt.bc
```

The code of gemmini-rocc-tests we use to run in RTL simulation to validate cosim is provided in https://github.com/charlieisacat/cosim_validation.

# TODO
We will release code for simulating custom instructions soon.